<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>量子光学器件交互演示 - 马赫-曾德尔干涉仪</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        
        body {
            background: linear-gradient(135deg, #0c0c2e 0%, #1a1a3e 100%);
            color: #e0e0ff;
            min-height: 100vh;
            padding: 20px;
            line-height: 1.6;
        }
        
        .container {
            max-width: 1400px;
            margin: 0 auto;
        }
        
        header {
            text-align: center;
            margin-bottom: 30px;
            padding-bottom: 20px;
            border-bottom: 1px solid rgba(100, 150, 255, 0.3);
        }
        
        h1 {
            font-size: 2.8rem;
            background: linear-gradient(90deg, #8a2be2, #00bfff);
            -webkit-background-clip: text;
            background-clip: text;
            color: transparent;
            margin-bottom: 10px;
        }
        
        .subtitle {
            font-size: 1.2rem;
            color: #a0a0ff;
            max-width: 800px;
            margin: 0 auto;
        }
        
        .main-content {
            display: flex;
            flex-wrap: wrap;
            gap: 30px;
            margin-bottom: 40px;
        }
        
        .demo-area {
            flex: 1;
            min-width: 300px;
            background: rgba(20, 20, 50, 0.7);
            border-radius: 15px;
            padding: 25px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
            border: 1px solid rgba(100, 150, 255, 0.2);
        }
        
        .control-panel {
            flex: 1;
            min-width: 300px;
            background: rgba(20, 20, 50, 0.7);
            border-radius: 15px;
            padding: 25px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
            border: 1px solid rgba(100, 150, 255, 0.2);
        }
        
        .canvas-container {
            position: relative;
            width: 100%;
            height: 500px;
            background: rgba(10, 10, 30, 0.9);
            border-radius: 10px;
            overflow: hidden;
            border: 1px solid #4a4aff;
        }
        
        #quantumCanvas {
            width: 100%;
            height: 100%;
        }
        
        .panel-title {
            font-size: 1.5rem;
            color: #7fffd4;
            margin-bottom: 20px;
            padding-bottom: 10px;
            border-bottom: 1px solid rgba(100, 150, 255, 0.3);
        }
        
        .control-group {
            margin-bottom: 25px;
        }
        
        .control-label {
            display: block;
            margin-bottom: 8px;
            font-size: 1.1rem;
            color: #b0b0ff;
        }
        
        .slider-container {
            display: flex;
            align-items: center;
            margin-bottom: 5px;
        }
        
        .slider-value {
            min-width: 50px;
            text-align: center;
            font-weight: bold;
            color: #00ffff;
        }
        
        input[type="range"] {
            flex: 1;
            height: 10px;
            -webkit-appearance: none;
            background: linear-gradient(90deg, #1a1a5e, #4a4aff);
            border-radius: 5px;
            outline: none;
        }
        
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 22px;
            height: 22px;
            border-radius: 50%;
            background: #00ffff;
            cursor: pointer;
            box-shadow: 0 0 10px #00ffff;
        }
        
        .control-description {
            font-size: 0.9rem;
            color: #a0a0cc;
            margin-top: 5px;
        }
        
        .button-group {
            display: flex;
            gap: 15px;
            margin-top: 10px;
        }
        
        button {
            flex: 1;
            padding: 12px 20px;
            background: linear-gradient(90deg, #2a2a8a, #4a4aff);
            border: none;
            border-radius: 8px;
            color: white;
            font-size: 1rem;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s;
            box-shadow: 0 5px 15px rgba(0, 0, 100, 0.3);
        }
        
        button:hover {
            transform: translateY(-3px);
            box-shadow: 0 8px 20px rgba(0, 100, 255, 0.4);
            background: linear-gradient(90deg, #3a3a9a, #5a5aff);
        }
        
        button:active {
            transform: translateY(0);
        }
        
        .mode-selector {
            display: flex;
            background: rgba(30, 30, 70, 0.8);
            border-radius: 10px;
            padding: 5px;
            margin-bottom: 25px;
        }
        
        .mode-btn {
            flex: 1;
            padding: 12px;
            text-align: center;
            background: transparent;
            border-radius: 8px;
            transition: all 0.3s;
            box-shadow: none;
        }
        
        .mode-btn.active {
            background: rgba(100, 150, 255, 0.3);
            box-shadow: 0 0 15px rgba(100, 150, 255, 0.5);
        }
        
        .results-panel {
            background: rgba(20, 20, 50, 0.7);
            border-radius: 15px;
            padding: 25px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
            border: 1px solid rgba(100, 150, 255, 0.2);
            margin-top: 20px;
        }
        
        .results-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            margin-top: 20px;
        }
        
        .result-box {
            background: rgba(30, 30, 70, 0.8);
            padding: 20px;
            border-radius: 10px;
            text-align: center;
            border-left: 4px solid #00ffff;
        }
        
        .result-value {
            font-size: 2rem;
            font-weight: bold;
            color: #00ffff;
            margin: 10px 0;
        }
        
        .result-label {
            font-size: 1rem;
            color: #b0b0ff;
        }
        
        .quantum-state {
            font-family: 'Courier New', monospace;
            background: rgba(0, 0, 0, 0.5);
            padding: 15px;
            border-radius: 8px;
            margin-top: 15px;
            border: 1px solid #4a4aff;
            color: #00ffaa;
        }
        
        footer {
            text-align: center;
            margin-top: 40px;
            padding-top: 20px;
            border-top: 1px solid rgba(100, 150, 255, 0.3);
            color: #a0a0cc;
            font-size: 0.9rem;
        }
        
        @media (max-width: 768px) {
            .main-content {
                flex-direction: column;
            }
            
            h1 {
                font-size: 2.2rem;
            }
            
            .canvas-container {
                height: 400px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>量子光学器件交互演示</h1>
            <p class="subtitle">马赫-曾德尔干涉仪 (Mach-Zehnder Interferometer) - 演示量子叠加、干涉和测量</p>
        </header>
        
        <div class="main-content">
            <div class="demo-area">
                <h2 class="panel-title">量子光学实验演示</h2>
                <div class="mode-selector">
                    <button class="mode-btn active" id="singlePhotonMode">单光子模式</button>
                    <button class="mode-btn" id="coherentLightMode">相干光模式</button>
                    <button class="mode-btn" id="entangledPhotonMode">纠缠光子模式</button>
                </div>
                <div class="canvas-container">
                    <canvas id="quantumCanvas"></canvas>
                </div>
            </div>
            
            <div class="control-panel">
                <h2 class="panel-title">实验参数控制</h2>
                
                <div class="control-group">
                    <label class="control-label">相位差 (Δφ): <span id="phaseValue" class="slider-value">0.00π</span></label>
                    <div class="slider-container">
                        <input type="range" id="phaseSlider" min="0" max="200" value="0" step="1">
                    </div>
                    <p class="control-description">调整干涉仪两臂之间的相位差，观察干涉图样的变化</p>
                </div>
                
                <div class="control-group">
                    <label class="control-label">分束器反射率 (R): <span id="reflectivityValue" class="slider-value">0.50</span></label>
                    <div class="slider-container">
                        <input type="range" id="reflectivitySlider" min="0" max="100" value="50" step="1">
                    </div>
                    <p class="control-description">调整分束器的反射率，控制光子的路径选择概率</p>
                </div>
                
                <div class="control-group">
                    <label class="control-label">光子发射速率: <span id="rateValue" class="slider-value">中速</span></label>
                    <div class="slider-container">
                        <input type="range" id="rateSlider" min="1" max="3" value="2" step="1">
                    </div>
                    <p class="control-description">调整光子发射速率，观察干涉图样的形成过程</p>
                </div>
                
                <div class="button-group">
                    <button id="startBtn">启动实验</button>
                    <button id="resetBtn">重置实验</button>
                    <button id="singlePhotonBtn">发射单光子</button>
                </div>
                
                <div class="control-group">
                    <h3 class="control-label">量子态表示</h3>
                    <div class="quantum-state" id="quantumState">
                        |ψ⟩ = 1/√2 (|路径1⟩ + e^{iΔφ}|路径2⟩)
                    </div>
                </div>
            </div>
        </div>
        
        <div class="results-panel">
            <h2 class="panel-title">实验结果分析</h2>
            <div class="results-grid">
                <div class="result-box">
                    <div class="result-label">探测器 D1 计数</div>
                    <div class="result-value" id="detector1Count">0</div>
                    <div class="result-label" id="detector1Prob">概率: 0%</div>
                </div>
                <div class="result-box">
                    <div class="result-label">探测器 D2 计数</div>
                    <div class="result-value" id="detector2Count">0</div>
                    <div class="result-label" id="detector2Prob">概率: 0%</div>
                </div>
                <div class="result-box">
                    <div class="result-label">干涉可见度</div>
                    <div class="result-value" id="visibilityValue">0.00</div>
                    <div class="result-label">V = (I_max - I_min)/(I_max + I_min)</div>
                </div>
                <div class="result-box">
                    <div class="result-label">符合计数</div>
                    <div class="result-value" id="coincidenceCount">0</div>
                    <div class="result-label">纠缠光子验证</div>
                </div>
            </div>
            
            <div class="control-group">
                <h3 class="control-label">实验说明</h3>
                <p class="control-description">
                    马赫-曾德尔干涉仪是量子光学的基本器件，用于演示量子叠加原理和波粒二象性。
                    单光子通过第一个分束器后处于两个路径的叠加态，在第二个分束器处发生干涉。
                    调整相位差可以观察到探测器计数随相位变化的干涉图样，这是量子力学基本原理的直接体现。
                </p>
            </div>
        </div>
        
        <footer>
            <p>量子光学交互演示系统 | 展示量子叠加、干涉和测量 | 仅供教学演示使用</p>
            <p>提示：尝试调整参数观察量子干涉现象，点击"发射单光子"观察单个光子的行为</p>
        </footer>
    </div>

    <script>
        // 获取Canvas和上下文
        const canvas = document.getElementById('quantumCanvas');
        const ctx = canvas.getContext('2d');
        
        // 设置Canvas尺寸
        function resizeCanvas() {
            const container = canvas.parentElement;
            canvas.width = container.clientWidth;
            canvas.height = container.clientHeight;
        }
        
        // 初始调整Canvas大小
        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);
        
        // 实验状态变量
        let experimentRunning = false;
        let animationId = null;
        let currentMode = 'singlePhoton'; // 'singlePhoton', 'coherentLight', 'entangledPhoton'
        
        // 实验参数
        let phaseDifference = 0; // 相位差 (0-2π)
        let reflectivity = 0.5;  // 反射率 (0-1)
        let photonRate = 2;      // 光子发射速率 (1-3)
        
        // 探测器计数
        let detector1Count = 0;
        let detector2Count = 0;
        let coincidenceCount = 0;
        
        // 光子数组
        let photons = [];
        let lastPhotonTime = 0;
        
        // 干涉仪组件位置
        let interferometerComponents = {
            laser: {x: 0.1, y: 0.5},
            beamSplitter1: {x: 0.3, y: 0.5},
            mirror1: {x: 0.5, y: 0.3},
            mirror2: {x: 0.5, y: 0.7},
            beamSplitter2: {x: 0.7, y: 0.5},
            detector1: {x: 0.9, y: 0.3},
            detector2: {x: 0.9, y: 0.7}
        };
        
        // 将相对坐标转换为Canvas坐标
        function toCanvasCoords(relX, relY) {
            return {
                x: relX * canvas.width,
                y: relY * canvas.height
            };
        }
        
        // 绘制干涉仪
        function drawInterferometer() {
            // 清空Canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // 绘制激光源
            const laserPos = toCanvasCoords(interferometerComponents.laser.x, interferometerComponents.laser.y);
            ctx.fillStyle = '#ff3333';
            ctx.beginPath();
            ctx.arc(laserPos.x, laserPos.y, 15, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillStyle = '#ff6666';
            ctx.beginPath();
            ctx.arc(laserPos.x, laserPos.y, 10, 0, Math.PI * 2);
            ctx.fill();
            
            // 绘制激光光束
            ctx.strokeStyle = experimentRunning ? 'rgba(255, 50, 50, 0.7)' : 'rgba(255, 50, 50, 0.3)';
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.moveTo(laserPos.x + 15, laserPos.y);
            const bs1Pos = toCanvasCoords(interferometerComponents.beamSplitter1.x, interferometerComponents.beamSplitter1.y);
            ctx.lineTo(bs1Pos.x, bs1Pos.y);
            ctx.stroke();
            
            // 绘制分束器1
            ctx.fillStyle = 'rgba(100, 200, 255, 0.7)';
            ctx.fillRect(bs1Pos.x - 20, bs1Pos.y - 40, 40, 80);
            ctx.strokeStyle = '#00ffff';
            ctx.lineWidth = 2;
            ctx.strokeRect(bs1Pos.x - 20, bs1Pos.y - 40, 40, 80);
            
            // 绘制分束器上的对角线
            ctx.strokeStyle = '#ffffff';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(bs1Pos.x - 15, bs1Pos.y - 35);
            ctx.lineTo(bs1Pos.x + 15, bs1Pos.y + 35);
            ctx.stroke();
            
            // 绘制路径1 (上路径)
            const mirror1Pos = toCanvasCoords(interferometerComponents.mirror1.x, interferometerComponents.mirror1.y);
            ctx.strokeStyle = experimentRunning ? 'rgba(100, 255, 100, 0.7)' : 'rgba(100, 255, 100, 0.3)';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(bs1Pos.x, bs1Pos.y - 35);
            ctx.lineTo(mirror1Pos.x - 30, mirror1Pos.y);
            ctx.lineTo(mirror1Pos.x, mirror1Pos.y);
            ctx.stroke();
            
            // 绘制路径2 (下路径)
            const mirror2Pos = toCanvasCoords(interferometerComponents.mirror2.x, interferometerComponents.mirror2.y);
            ctx.strokeStyle = experimentRunning ? 'rgba(255, 255, 100, 0.7)' : 'rgba(255, 255, 100, 0.3)';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(bs1Pos.x, bs1Pos.y + 35);
            ctx.lineTo(mirror2Pos.x - 30, mirror2Pos.y);
            ctx.lineTo(mirror2Pos.x, mirror2Pos.y);
            ctx.stroke();
            
            // 绘制反射镜1
            ctx.fillStyle = 'rgba(200, 200, 200, 0.8)';
            ctx.fillRect(mirror1Pos.x - 5, mirror1Pos.y - 30, 10, 60);
            ctx.strokeStyle = '#ffffff';
            ctx.lineWidth = 1;
            ctx.strokeRect(mirror1Pos.x - 5, mirror1Pos.y - 30, 10, 60);
            
            // 绘制反射镜2
            ctx.fillStyle = 'rgba(200, 200, 200, 0.8)';
            ctx.fillRect(mirror2Pos.x - 5, mirror2Pos.y - 30, 10, 60);
            ctx.strokeStyle = '#ffffff';
            ctx.lineWidth = 1;
            ctx.strokeRect(mirror2Pos.x - 5, mirror2Pos.y - 30, 10, 60);
            
            // 绘制从反射镜到分束器2的路径
            const bs2Pos = toCanvasCoords(interferometerComponents.beamSplitter2.x, interferometerComponents.beamSplitter2.y);
            
            // 上路径继续
            ctx.strokeStyle = experimentRunning ? 'rgba(100, 255, 100, 0.7)' : 'rgba(100, 255, 100, 0.3)';
            ctx.beginPath();
            ctx.moveTo(mirror1Pos.x, mirror1Pos.y);
            ctx.lineTo(bs2Pos.x - 40, bs2Pos.y - 35);
            ctx.lineTo(bs2Pos.x, bs2Pos.y - 35);
            ctx.stroke();
            
            // 下路径继续
            ctx.strokeStyle = experimentRunning ? 'rgba(255, 255, 100, 0.7)' : 'rgba(255, 255, 100, 0.3)';
            ctx.beginPath();
            ctx.moveTo(mirror2Pos.x, mirror2Pos.y);
            ctx.lineTo(bs2Pos.x - 40, bs2Pos.y + 35);
            ctx.lineTo(bs2Pos.x, bs2Pos.y + 35);
            ctx.stroke();
            
            // 绘制分束器2
            ctx.fillStyle = 'rgba(100, 200, 255, 0.7)';
            ctx.fillRect(bs2Pos.x - 20, bs2Pos.y - 40, 40, 80);
            ctx.strokeStyle = '#00ffff';
            ctx.lineWidth = 2;
            ctx.strokeRect(bs2Pos.x - 20, bs2Pos.y - 40, 40, 80);
            
            // 绘制分束器2上的对角线
            ctx.strokeStyle = '#ffffff';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(bs2Pos.x - 15, bs2Pos.y - 35);
            ctx.lineTo(bs2Pos.x + 15, bs2Pos.y + 35);
            ctx.stroke();
            
            // 绘制到探测器的路径
            const detector1Pos = toCanvasCoords(interferometerComponents.detector1.x, interferometerComponents.detector1.y);
            const detector2Pos = toCanvasCoords(interferometerComponents.detector2.x, interferometerComponents.detector2.y);
            
            // 到探测器1的路径
            ctx.strokeStyle = experimentRunning ? 'rgba(255, 150, 50, 0.7)' : 'rgba(255, 150, 50, 0.3)';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(bs2Pos.x, bs2Pos.y - 35);
            ctx.lineTo(detector1Pos.x, detector1Pos.y);
            ctx.stroke();
            
            // 到探测器2的路径
            ctx.strokeStyle = experimentRunning ? 'rgba(150, 100, 255, 0.7)' : 'rgba(150, 100, 255, 0.3)';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(bs2Pos.x, bs2Pos.y + 35);
            ctx.lineTo(detector2Pos.x, detector2Pos.y);
            ctx.stroke();
            
            // 绘制探测器1
            ctx.fillStyle = detector1Count > 0 ? 'rgba(255, 150, 50, 0.9)' : 'rgba(100, 100, 100, 0.7)';
            ctx.beginPath();
            ctx.arc(detector1Pos.x, detector1Pos.y, 20, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillStyle = '#ffffff';
            ctx.font = 'bold 14px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText('D1', detector1Pos.x, detector1Pos.y);
            
            // 绘制探测器2
            ctx.fillStyle = detector2Count > 0 ? 'rgba(150, 100, 255, 0.9)' : 'rgba(100, 100, 100, 0.7)';
            ctx.beginPath();
            ctx.arc(detector2Pos.x, detector2Pos.y, 20, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillStyle = '#ffffff';
            ctx.font = 'bold 14px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText('D2', detector2Pos.x, detector2Pos.y);
            
            // 绘制相位指示器
            ctx.fillStyle = 'rgba(100, 200, 255, 0.5)';
            ctx.fillRect(canvas.width * 0.45, canvas.height * 0.45, 100, 40);
            ctx.strokeStyle = '#00ffff';
            ctx.lineWidth = 1;
            ctx.strokeRect(canvas.width * 0.45, canvas.height * 0.45, 100, 40);
            ctx.fillStyle = '#ffffff';
            ctx.font = '14px Arial';
            ctx.textAlign = 'center';
            ctx.fillText(`Δφ = ${(phaseDifference / Math.PI).toFixed(2)}π`, canvas.width * 0.5, canvas.height * 0.47 + 15);
            
            // 绘制分束器反射率指示器
            ctx.fillStyle = 'rgba(100, 200, 255, 0.5)';
            ctx.fillRect(canvas.width * 0.3, canvas.height * 0.1, 80, 30);
            ctx.strokeStyle = '#00ffff';
            ctx.lineWidth = 1;
            ctx.strokeRect(canvas.width * 0.3, canvas.height * 0.1, 80, 30);
            ctx.fillStyle = '#ffffff';
            ctx.font = '12px Arial';
            ctx.textAlign = 'center';
            ctx.fillText(`R = ${reflectivity.toFixed(2)}`, canvas.width * 0.3 + 40, canvas.height * 0.1 + 18);
        }
        
        // 光子类
        class Photon {
            constructor(path, entangled = false) {
                this.path = path; // 'upper' 或 'lower'
                this.entangled = entangled;
                this.position = {x: 0.1, y: 0.5};
                this.speed = 0.005;
                this.phase = 0;
                this.state = 'laser'; // 'laser', 'path1', 'path2', 'detected'
                this.detectedAt = null;
                this.arrivalTime = 0;
                this.color = this.getColor();
                this.partner = null; // 纠缠伙伴
            }
            
            getColor() {
                if (this.entangled) return '#ff00ff';
                if (this.path === 'upper') return '#00ff00';
                return '#ffff00';
            }
            
            update(deltaTime) {
                if (this.state === 'detected') return;
                
                // 更新相位
                this.phase += deltaTime * 10;
                
                // 根据状态更新位置
                switch(this.state) {
                    case 'laser':
                        this.position.x += this.speed;
                        if (this.position.x >= 0.3) {
                            this.state = 'atBeamSplitter1';
                            // 随机选择路径 (基于反射率)
                            this.path = Math.random() < reflectivity ? 'upper' : 'lower';
                        }
                        break;
                        
                    case 'atBeamSplitter1':
                        if (this.path === 'upper') {
                            this.position.x += this.speed * 0.7;
                            this.position.y -= this.speed * 0.7;
                            if (this.position.y <= 0.3) {
                                this.state = 'path1';
                            }
                        } else {
                            this.position.x += this.speed * 0.7;
                            this.position.y += this.speed * 0.7;
                            if (this.position.y >= 0.7) {
                                this.state = 'path2';
                            }
                        }
                        break;
                        
                    case 'path1':
                        this.position.x += this.speed;
                        if (this.position.x >= 0.5) {
                            this.state = 'atMirror1';
                        }
                        break;
                        
                    case 'path2':
                        this.position.x += this.speed;
                        if (this.position.x >= 0.5) {
                            this.state = 'atMirror2';
                        }
                        break;
                        
                    case 'atMirror1':
                        this.position.x += this.speed * 0.7;
                        this.position.y += this.speed * 0.7;
                        if (this.position.y >= 0.5) {
                            this.state = 'toBeamSplitter2_upper';
                        }
                        break;
                        
                    case 'atMirror2':
                        this.position.x += this.speed * 0.7;
                        this.position.y -= this.speed * 0.7;
                        if (this.position.y <= 0.5) {
                            this.state = 'toBeamSplitter2_lower';
                        }
                        break;
                        
                    case 'toBeamSplitter2_upper':
                        this.position.x += this.speed;
                        if (this.position.x >= 0.7) {
                            this.state = 'atBeamSplitter2';
                        }
                        break;
                        
                    case 'toBeamSplitter2_lower':
                        this.position.x += this.speed;
                        if (this.position.x >= 0.7) {
                            this.state = 'atBeamSplitter2';
                        }
                        break;
                        
                    case 'atBeamSplitter2':
                        // 计算干涉概率
                        const amplitudeUpper = Math.sqrt(1 - reflectivity); // 上路径振幅
                        const amplitudeLower = Math.sqrt(reflectivity) * Math.cos(phaseDifference); // 下路径振幅（考虑相位）
                        
                        // 概率幅度平方
                        const probDetector1 = Math.pow(amplitudeUpper + amplitudeLower, 2) / 2;
                        const probDetector2 = Math.pow(amplitudeUpper - amplitudeLower, 2) / 2;
                        
                        // 归一化
                        const totalProb = probDetector1 + probDetector2;
                        const normProbDetector1 = probDetector1 / totalProb;
                        
                        // 随机选择探测器
                        const goesToDetector1 = Math.random() < normProbDetector1;
                        
                        if (goesToDetector1) {
                            this.detectedAt = 'D1';
                            detector1Count++;
                        } else {
                            this.detectedAt = 'D2';
                            detector2Count++;
                        }
                        
                        // 如果是纠缠光子且伙伴已检测到，更新符合计数
                        if (this.entangled && this.partner && this.partner.detectedAt) {
                            if (this.detectedAt !== this.partner.detectedAt) {
                                coincidenceCount++;
                            }
                        }
                        
                        this.state = 'toDetector';
                        this.arrivalTime = Date.now();
                        break;
                        
                    case 'toDetector':
                        if (this.detectedAt === 'D1') {
                            this.position.x += this.speed;
                            this.position.y -= this.speed * 0.7;
                            if (this.position.x >= 0.9) {
                                this.state = 'detected';
                            }
                        } else {
                            this.position.x += this.speed;
                            this.position.y += this.speed * 0.7;
                            if (this.position.x >= 0.9) {
                                this.state = 'detected';
                            }
                        }
                        break;
                }
            }
            
            draw() {
                const pos = toCanvasCoords(this.position.x, this.position.y);
                
                // 绘制光子
                ctx.fillStyle = this.color;
                ctx.beginPath();
                ctx.arc(pos.x, pos.y, 6, 0, Math.PI * 2);
                ctx.fill();
                
                // 绘制光晕
                ctx.strokeStyle = this.color;
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.arc(pos.x, pos.y, 10, 0, Math.PI * 2);
                ctx.stroke();
                
                // 如果处于叠加态，绘制波动效果
                if (this.state === 'path1' || this.state === 'path2') {
                    ctx.strokeStyle = `${this.color}80`;
                    ctx.lineWidth = 1;
                    ctx.beginPath();
                    const waveRadius = 15 + Math.sin(this.phase) * 5;
                    ctx.arc(pos.x, pos.y, waveRadius, 0, Math.PI * 2);
                    ctx.stroke();
                }
                
                // 如果已被检测到，绘制检测效果
                if (this.state === 'detected' && Date.now() - this.arrivalTime < 500) {
                    ctx.strokeStyle = `${this.color}`;
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    const pulseRadius = 20 + (Date.now() - this.arrivalTime) / 10;
                    ctx.arc(pos.x, pos.y, pulseRadius, 0, Math.PI * 2);
                    ctx.stroke();
                }
            }
        }
        
        // 发射单光子
        function emitSinglePhoton() {
            const photon = new Photon('upper');
            photons.push(photon);
            updateResults();
        }
        
        // 发射纠缠光子对
        function emitEntangledPhotons() {
            const photon1 = new Photon('upper', true);
            const photon2 = new Photon('lower', true);
            photon1.partner = photon2;
            photon2.partner = photon1;
            photons.push(photon1, photon2);
            updateResults();
        }
        
        // 更新光子
        function updatePhotons(deltaTime) {
            for (let i = photons.length - 1; i >= 0; i--) {
                photons[i].update(deltaTime);
                
                // 移除已检测到一段时间的光子
                if (photons[i].state === 'detected' && Date.now() - photons[i].arrivalTime > 1000) {
                    photons.splice(i, 1);
                }
            }
        }
        
        // 绘制所有光子
        function drawPhotons() {
            photons.forEach(photon => photon.draw());
        }
        
        // 更新结果显示
        function updateResults() {
            // 更新探测器计数
            document.getElementById('detector1Count').textContent = detector1Count;
            document.getElementById('detector2Count').textContent = detector2Count;
            document.getElementById('coincidenceCount').textContent = coincidenceCount;
            
            // 计算概率
            const totalDetections = detector1Count + detector2Count;
            const prob1 = totalDetections > 0 ? (detector1Count / totalDetections * 100).toFixed(1) : 0;
            const prob2 = totalDetections > 0 ? (detector2Count / totalDetections * 100).toFixed(1) : 0;
            
            document.getElementById('detector1Prob').textContent = `概率: ${prob1}%`;
            document.getElementById('detector2Prob').textContent = `概率: ${prob2}%`;
            
            // 计算干涉可见度
            const maxCount = Math.max(detector1Count, detector2Count);
            const minCount = Math.min(detector1Count, detector2Count);
            const visibility = totalDetections > 0 ? ((maxCount - minCount) / (maxCount + minCount)).toFixed(2) : 0;
            document.getElementById('visibilityValue').textContent = visibility;
            
            // 更新量子态表示
            const phaseInPi = (phaseDifference / Math.PI).toFixed(2);
            let quantumStateText = '';
            
            if (currentMode === 'singlePhoton') {
                quantumStateText = `|ψ⟩ = √${(1-reflectivity).toFixed(2)}|上路径⟩ + e^{i${phaseInPi}π}√${reflectivity.toFixed(2)}|下路径⟩`;
            } else if (currentMode === 'coherentLight') {
                quantumStateText = `相干光强度: I = I₀[1 + V cos(Δφ)]，可见度 V = ${visibility}`;
            } else {
                quantumStateText = `纠缠态: |Ψ⁺⟩ = 1/√2 (|上路径₁, 下路径₂⟩ + |下路径₁, 上路径₂⟩)`;
            }
            
            document.getElementById('quantumState').textContent = quantumStateText;
        }
        
        // 动画循环
        function animate(timestamp) {
            if (!lastPhotonTime) lastPhotonTime = timestamp;
            const deltaTime = timestamp - lastPhotonTime;
            lastPhotonTime = timestamp;
            
            // 如果实验正在运行，自动发射光子
            if (experimentRunning && currentMode !== 'entangledPhoton') {
                const rate = photonRate === 1 ? 1000 : photonRate === 2 ? 500 : 200;
                if (timestamp % rate < deltaTime) {
                    emitSinglePhoton();
                }
            } else if (experimentRunning && currentMode === 'entangledPhoton') {
                const rate = photonRate === 1 ? 2000 : photonRate === 2 ? 1000 : 500;
                if (timestamp % rate < deltaTime) {
                    emitEntangledPhotons();
                }
            }
            
            // 更新光子位置
            updatePhotons(deltaTime / 1000);
            
            // 绘制场景
            drawInterferometer();
            drawPhotons();
            
            // 继续动画循环
            animationId = requestAnimationFrame(animate);
        }
        
        // 初始化事件监听
        function initEventListeners() {
            // 相位滑块
            const phaseSlider = document.getElementById('phaseSlider');
            phaseSlider.addEventListener('input', function() {
                phaseDifference = (this.value / 100) * Math.PI * 2;
                document.getElementById('phaseValue').textContent = (phaseDifference / Math.PI).toFixed(2) + 'π';
                updateResults();
            });
            
            // 反射率滑块
            const reflectivitySlider = document.getElementById('reflectivitySlider');
            reflectivitySlider.addEventListener('input', function() {
                reflectivity = this.value / 100;
                document.getElementById('reflectivityValue').textContent = reflectivity.toFixed(2);
                updateResults();
            });
            
            // 速率滑块
            const rateSlider = document.getElementById('rateSlider');
            rateSlider.addEventListener('input', function() {
                photonRate = parseInt(this.value);
                const rateText = photonRate === 1 ? '慢速' : photonRate === 2 ? '中速' : '快速';
                document.getElementById('rateValue').textContent = rateText;
            });
            
            // 模式切换按钮
            document.getElementById('singlePhotonMode').addEventListener('click', function() {
                setMode('singlePhoton');
            });
            
            document.getElementById('coherentLightMode').addEventListener('click', function() {
                setMode('coherentLight');
            });
            
            document.getElementById('entangledPhotonMode').addEventListener('click', function() {
                setMode('entangledPhoton');
            });
            
            // 控制按钮
            document.getElementById('startBtn').addEventListener('click', function() {
                experimentRunning = !experimentRunning;
                this.textContent = experimentRunning ? '暂停实验' : '启动实验';
                
                if (experimentRunning && !animationId) {
                    lastPhotonTime = 0;
                    animationId = requestAnimationFrame(animate);
                }
            });
            
            document.getElementById('resetBtn').addEventListener('click', function() {
                // 重置实验
                photons = [];
                detector1Count = 0;
                detector2Count = 0;
                coincidenceCount = 0;
                updateResults();
                
                // 如果是首次启动，开始动画
                if (!animationId) {
                    animationId = requestAnimationFrame(animate);
                }
            });
            
            document.getElementById('singlePhotonBtn').addEventListener('click', function() {
                if (currentMode === 'entangledPhoton') {
                    emitEntangledPhotons();
                } else {
                    emitSinglePhoton();
                }
                
                // 如果是首次启动，开始动画
                if (!animationId) {
                    animationId = requestAnimationFrame(animate);
                }
            });
        }
        
        // 设置模式
        function setMode(mode) {
            currentMode = mode;
            
            // 更新模式按钮状态
            document.getElementById('singlePhotonMode').classList.remove('active');
            document.getElementById('coherentLightMode').classList.remove('active');
            document.getElementById('entangledPhotonMode').classList.remove('active');
            document.getElementById(`${mode}Mode`).classList.add('active');
            
            // 重置实验
            photons = [];
            detector1Count = 0;
            detector2Count = 0;
            coincidenceCount = 0;
            
            // 根据模式调整参数
            if (mode === 'coherentLight') {
                // 相干光模式下，反射率固定为0.5
                reflectivity = 0.5;
                document.getElementById('reflectivitySlider').value = 50;
                document.getElementById('reflectivityValue').textContent = '0.50';
                document.getElementById('reflectivitySlider').disabled = true;
            } else {
                document.getElementById('reflectivitySlider').disabled = false;
            }
            
            updateResults();
        }
        
        // 初始化应用
        function init() {
            // 设置初始模式
            setMode('singlePhoton');
            
            // 初始化事件监听
            initEventListeners();
            
            // 启动动画循环
            animationId = requestAnimationFrame(animate);
            
            // 初始绘制
            drawInterferometer();
            updateResults();
            
            // 添加键盘快捷键
            document.addEventListener('keydown', function(e) {
                if (e.key === ' ') {
                    // 空格键发射单光子
                    emitSinglePhoton();
                } else if (e.key === 'r' || e.key === 'R') {
                    // R键重置实验
                    photons = [];
                    detector1Count = 0;
                    detector2Count = 0;
                    coincidenceCount = 0;
                    updateResults();
                }
            });
        }
        
        // 页面加载完成后初始化
        window.addEventListener('load', init);
    </script>
</body>
</html>